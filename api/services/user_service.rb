require './api/models/user'
require './api/repositories/user_repository'
require './api/services/hash_service'
require './api/gateways/product_gateway'
require './api/constants/error_constants'
require './api/errors/api_error'
require './api/utils/time_util'
require './api/services/config_service'

class UserService

  include ErrorConstants::ApiErrors
  include TimeUtil

  def initialize(user_repository = UserRepository, hash_service = HashService, product_gateway = ProductGateway,
                 config_service = ConfigurationService)
    @user_repository = user_repository.new
    @hash_service = hash_service.new
    @product_gateway = product_gateway.new
    @config = config_service.new.get_config
  end

  def create_or_update(validated_auth)
    username = validated_auth[:username]
    user = get_by_username username

    return user if (user != nil && user.third_party_id.to_s != '')

    external_id = validated_auth[:id] # this is the user id generated by ID-IO
    first_name = validated_auth[:first_name]
    last_name = validated_auth[:last_name]
    email = validated_auth[:email]
    mobile_number = validated_auth[:mobile_number]

    third_party_user_result = @product_gateway.create_user username, email, first_name, last_name, mobile_number
    new_external_user = JSON.parse(third_party_user_result.response_body, :symbolize_names => true)
    third_party_id = new_external_user[:customer][:id].to_s
    start_balance = @config[:signup_credit_enabled] ? @config[:default_signup_credit] : 0

    @user_repository.create external_id, third_party_id, username, first_name, last_name, email, mobile_number, start_balance

  end

  #TODO: refactor this to handle paging
  def get_all
    @user_repository.get_all_users
  end

  def get_by_id(user_id)
    @user_repository.get_user user_id.to_s
  end

  def get_by_username(username, user = nil)
    result = @user_repository.get_by_username username
    raise ApiError, INVALID_USERNAME if (result != nil && result.username != username) if user != nil

    result
  end

  def get_all_with_pending_balance
    @user_repository.get_all_with_pending_balance
  end

  def clear_pending_balance(user)
    pending_balance = user.pending_balance
    user.balance += pending_balance
    user.pending_balance = 0

    user.save
  end

  def update(username, first_name, last_name, password)
    #TODO: update the DB - username is the identifier and cannot be changed
    raise 'User update not implemented'
  end

  def update_balance(user_id, amount)
    user = get_by_id user_id

    if @config[:trading_hours_active]
      # check if we're in-hours
      current_hour = TimeUtil.get_current_hour_in_zone @config[:time_zone]
      (current_hour < @config[:trading_hours_start] || current_hour > @config[:trading_hours_end]) ?
          user.pending_balance += amount :
          user.balance += amount
    else
      user.balance += amount
    end

    user.save

    {:pending_balance => user.pending_balance, :balance => user.balance}
  end

  def delete(username)
    #TODO: delete from the DB - username is the identifier
    raise 'User delete not implemented'
  end

end
require './api/models/user'
require './api/models/card'
require './api/repositories/user_repository'
require './api/repositories/card_repository'
require './api/services/hash_service'
require './api/gateways/product_gateway'
require './api/constants/error_constants'
require './api/errors/api_error'
require './api/utils/time_util'
require './api/services/config_service'
require './api/constants/api_constants'

class UserService

  include ErrorConstants::ApiErrors
  include TimeUtil
  include ApiConstants::MembershipConstants

  def initialize(user_repository = UserRepository, card_repository = CardRepository,
                 hash_service = HashService, product_gateway = ProductGateway,
                 config_service = ConfigurationService)
    @user_repository = user_repository.new
    @card_repository = card_repository.new
    @hash_service = hash_service.new
    @product_gateway = product_gateway.new
    @config = config_service.new.get_config
  end

  def create_or_update(validated_auth)
    username = validated_auth[:username]
    user = get_by_username username

    return user if (user != nil && user.third_party_id.to_s != '')

    external_id = validated_auth[:id] # this is the user id generated by ID-IO
    first_name = validated_auth[:first_name]
    last_name = validated_auth[:last_name]
    email = validated_auth[:email]
    mobile_number = validated_auth[:mobile_number]
    meta = validated_auth[:meta]

    third_party_user_result = @product_gateway.create_user username, email, first_name, last_name, mobile_number
    new_external_user = JSON.parse(third_party_user_result.response_body, :symbolize_names => true)
    third_party_id = new_external_user[:customer][:id].to_s

    #TODO: create a new order for credit
    start_balance = @config[:signup_credit_enabled] ? @config[:default_signup_credit] : 0

    @user_repository.create external_id, third_party_id, username, first_name, last_name, email, mobile_number, meta, start_balance

    # create new vinos_bonus order type


  end

  #TODO: refactor this to handle paging
  def get_all
    @user_repository.get_all_users
  end

  def get_by_id(user_id)
    @user_repository.get_user user_id.to_s
  end

  def get_by_username(username, user = nil)
    result = @user_repository.get_by_username username.to_s.downcase

    if user != nil
      #Â make sure that the current user is calling up his own details
      if (result != nil && result.username != user.username.to_s.downcase)
        raise ApiError, INVALID_USERNAME
      end
    end

    result
  end

  def get_by_username_with_cards(username, user = nil)
    result = get_by_username username, user
    result_json = JSON.parse(result.to_json, :symbolize_names => true)

    # get any cards associated with this user, and add to the user result
    cards = @card_repository.get_cards_for_user_redacted result.id.to_s
    cards_json = JSON.parse(cards.to_json, :symbolize_names => true)

    if result_json[:membership_type] == nil
      result_json[:membership_type] = MEMBERSHIP_TYPE_BASIC
    end

    (cards == nil) ? result_json[:cards] = [] : result_json[:cards] = cards_json

    result_json
  end

  def get_all_with_pending_balance
    @user_repository.get_all_with_pending_balance
  end

  def clear_pending_balance(user)
    pending_balance = user.pending_balance
    user.balance += pending_balance
    user.pending_balance = 0

    user.save
  end

  def update(username, first_name, last_name, password)
    #TODO: update the DB - username is the identifier and cannot be changed
    raise 'User update not implemented'
  end

  def update_balance(user_id, amount)
    user = get_by_id user_id

    if @config[:trading_hours_active]
      # check if we're in-hours
      current_day = TimeUtil.get_current_day_in_zone @config[:time_zone]
      current_hour = TimeUtil.get_current_hour_in_zone @config[:time_zone]

      current_day_allowed = @config[:trading_days].include? current_day
      current_hour_allowed = (@config[:trading_hours_start] < current_hour) && (@config[:trading_hours_end] > current_hour)

      (current_day_allowed && current_hour_allowed) ? user.balance += amount : user.pending_balance += amount

    else
      user.balance += amount
    end

    user.save

    {:pending_balance => user.pending_balance, :balance => user.balance}
  end

  def update_balance_for_redemption(user_id, amount)
    user = get_by_id user_id
    user.balance += amount

    user.save

    {:pending_balance => user.pending_balance, :balance => user.balance}
  end

  def update_balance_with_card(user_id, amount, registration_id, card)

    if registration_id != nil && card != nil
      # this automatically sets the current card as the default
      @card_repository.set_card_for_user(user_id, registration_id,
                                         card[:last4Digits],
                                         card[:holder],
                                         card[:expiryMonth],
                                         card[:expiryYear])
    end

    update_balance(user_id, amount)

  end

  def delete(username)
    #TODO: delete from the DB - username is the identifier
    raise 'User delete not implemented'
  end

end
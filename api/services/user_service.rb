require './api/models/user'
require './api/models/card'
require './api/repositories/user_repository'
require './api/repositories/card_repository'
require './api/services/hash_service'
require './api/gateways/product_gateway'
require './api/constants/error_constants'
require './api/errors/api_error'
require './api/utils/time_util'
require './api/services/config_service'
require './api/constants/api_constants'

class UserService

  include ErrorConstants::ApiErrors
  include TimeUtil
  include ApiConstants
  include ApiConstants::MembershipConstants

  def initialize(user_repository = UserRepository, card_repository = CardRepository,
                 hash_service = HashService, product_gateway = ProductGateway,
                 config_service = ConfigurationService)
    @user_repository = user_repository.new
    @card_repository = card_repository.new
    @hash_service = hash_service.new
    @product_gateway = product_gateway.new
    @config = config_service.new.get_config
  end

  def create_or_update(validated_auth)
    username = validated_auth[:username]
    user = get_by_username username

    return user if (user != nil && user.third_party_id.to_s != '')

    external_id = validated_auth[:id] # this is the user id generated by ID-IO
    first_name = validated_auth[:first_name]
    last_name = validated_auth[:last_name]
    email = validated_auth[:email]
    mobile_number = validated_auth[:mobile_number]
    meta = validated_auth[:meta]

    third_party_user_result = @product_gateway.create_user username, email, first_name, last_name, mobile_number
    new_external_user = JSON.parse(third_party_user_result.response_body, :symbolize_names => true)
    third_party_id = new_external_user[:customer][:id].to_s

    #TODO: create a new order for credit
    start_balance = @config[:signup_credit_enabled] ? @config[:default_signup_credit] : 0

    @user_repository.create external_id, third_party_id, username, first_name, last_name, email, mobile_number, meta, start_balance

    # create new vinos_bonus order type


  end

  #TODO: refactor this to handle paging
  def get_all
    @user_repository.get_all_users
  end

  def get_by_id(user_id)
    @user_repository.get_user user_id.to_s
  end

  def get_by_username(username, user = nil)
    result = @user_repository.get_by_username username.to_s.downcase

    if user != nil
      #Â make sure that the current user is calling up his own details
      if (result != nil && result.username != user.username.to_s.downcase)
        raise ApiError, INVALID_USERNAME
      end
    end

    result
  end

  def get_by_username_with_cards(username, user = nil)
    result = get_by_username username, user
    result_json = JSON.parse(result.to_json, :symbolize_names => true)

    # get any cards associated with this user, and add to the user result
    cards = @card_repository.get_cards_for_user_redacted result.id.to_s
    cards_json = JSON.parse(cards.to_json, :symbolize_names => true)

    result_json[:membership_type] = MEMBERSHIP_TYPE_BASIC if result_json[:membership_type] == nil

    (cards == nil) ? result_json[:cards] = [] : result_json[:cards] = cards_json

    result_json
  end

  def get_all_with_pending_balance
    @user_repository.get_all_with_pending_balance
  end

  def clear_pending_balance(user)
    pending_balance = user.pending_balance
    user.balance += pending_balance
    user.pending_balance = 0

    user.save
  end

  def update(username, first_name, last_name, password)
    #TODO: update the DB - username is the identifier and cannot be changed
    raise 'User update not implemented'
  end

  def update_balance(user_id, order_type, products, amount)
    user = get_by_id user_id

    # if a membership type, then bypass the trading hours restriction
    if order_type == MEMBERSHIP_PURCHASE_TYPE

      membership_type = MEMBERSHIP_TYPES.find do |type|
         type if products[0].name.downcase.include? type
      end

      new_balance = user.balance + amount
      @user_repository.update_balance_and_membership_type user_id, new_balance, membership_type
    else
      if @config[:trading_hours_active]

        # in-hours?
        if confirm_in_hours
          new_balance = user.balance + amount
          @user_repository.update_balance user_id, new_balance
          # user.balance += amount
        else
          # user.pending_balance += amount
          new_balance = user.pending_balance + amount
          @user_repository.update_pending_balance user_id, new_balance
        end

      else
        # user.balance += amount
        new_balance = user.balance + amount
        @user_repository.update_balance user_id, new_balance
      end
    end

    # user.save

    {:pending_balance => user.pending_balance, :balance => user.balance}
  end

  def confirm_in_hours
    current_day = TimeUtil.get_current_day_in_zone @config[:time_zone]
    current_hour = TimeUtil.get_current_hour_in_zone @config[:time_zone]

    current_day_allowed = @config[:trading_days].include? current_day
    current_hour_allowed = (@config[:trading_hours_start] < current_hour) && (@config[:trading_hours_end] > current_hour)

    current_day_allowed && current_hour_allowed
  end

  def update_balance_for_redemption(user_id, amount)
    user = get_by_id user_id
    # user.balance += amount
    # user.save

    new_balance = user.balance + amount
    @user_repository.update_balance user_id, new_balance

    {:pending_balance => user.pending_balance, :balance => new_balance}
  end

  def update_balance_with_card(order, amount, registration_id, card)

    if registration_id != nil && card != nil
      # this automatically sets the current card as the default
      @card_repository.set_card_for_user(order.user_id, registration_id,
                                         card[:last4Digits],
                                         card[:holder],
                                         card[:expiryMonth],
                                         card[:expiryYear])
    end

    update_balance(order.user_id, order.type, order.products, amount)

  end

  def update_membership(user_id, membership)
    @user_repository.update_membership_type user_id, membership
  end

  def delete(username)
    #TODO: delete from the DB - username is the identifier
    raise 'User delete not implemented'
  end

end